
*align.txt*	The Alignment Tool			Jun 18, 2012

Author:    Charles E. Campbell      <NdrOchip@ScampbellPfamily.AbizM>
           (remove NOSPAM from Campbell's email first)
Copyright: (c) 2004-2012 by Charles E. Campbell     	*Align-copyright*
           The VIM LICENSE applies to Align.vim, AlignMaps.vim, and Align.txt
           (see |copyright|) except use "Align and AlignMaps" instead of "Vim"
           NO WARRANTY, EXPRESS OR IMPLIED.  USE AT-YOUR-OWN-RISK.

==============================================================================
1. Contents					*align* *align-contents* {{{1

	1. Contents.................: |align-contents|
	2. Alignment Manual.........: |align-manual|
	3. Alignment Usage..........: |align-usage|
	   Alignment Concepts.......: |align-concepts|
	   Alignment Commands.......: |align-commands|
	   Alignment Control........: |align-control|
	     Separators.............: |alignctrl-separators|
	     Initial Whitespace.....: |alignctrl-w| |alignctrl-W| |alignctrl-I|
	     Justification..........: |alignctrl-l| |alignctrl-r| |alignctrl-c|
	     Justification Control..: |alignctrl--| |alignctrl-+| |alignctrl-:|
	     Cyclic/Sequential......: |alignctrl-=| |alignctrl-C|
	     Separator Justification: |alignctrl-<| |alignctrl->| |alignctrl-||
	     Line (de)Selection.....: |alignctrl-g| |alignctrl-v|
	     Temporary Settings.....: |alignctrl-m|
	     Padding................: |alignctrl-p| |alignctrl-P|
	     Current Options........: |alignctrl-settings| |alignctrl-|
	   Alignment Control Init...: |alignctrl-init|
	   Alignment................: |align-align|
	4. Alignment Maps...........: |align-maps|
	     \a,....................: |alignmap-a,|
	     \a?....................: |alignmap-a?|
	     \a<....................: |alignmap-a<|
	     \abox..................: |alignmap-abox|
	     \acom..................: |alignmap-acom|
	     \anum..................: |alignmap-anum|
	     \ascom.................: |alignmap-ascom|
	     \adec..................: |alignmap-adec|
	     \adef..................: |alignmap-adef|
	     \afnc..................: |alignmap-afnc|
	     \adcom.................: |alignmap-adcom|
	     \aocom.................: |alignmap-aocom|
	     \tsp...................: |alignmap-tsp|
	     \tsq...................: |alignmap-tsq|
	     \tt....................: |alignmap-tt|
	     \t=....................: |alignmap-t=|
	     \T=....................: |alignmap-T=|
	     \Htd...................: |alignmap-Htd|
	5. Alignment Tool History...: |align-history|

==============================================================================
2. Align Manual			*alignman* *alignmanual* *align-manual* {{{1

	Align comes as a vimball; simply typing >
		vim Align.vba.gz
		:so %
<	should put its components where they belong.  The components are: >
		.vim/plugin/AlignPlugin.vim
		.vim/plugin/AlignMapsPlugin.vim
		.vim/plugin/cecutil.vim
		.vim/autoload/Align.vim
		.vim/autoload/AlignMaps.vim
		.vim/doc/Align.txt
<	To see a user's guide, see |align-userguide|
	To see examples, see |alignctrl| and |alignmaps|
>
/=============+=========+=====================================================\
||            \ Default/                                                     ||
||  Commands   \ Value/                Explanation                           ||
||              |    |                                                       ||
++==============+====+=======================================================++
||  AlignCtrl   |    |  =Clrc-+:pPIWw [..list-of-separator-patterns..]       ||
||              |    +-------------------------------------------------------+|
||              |    |  may be called as a command or as a function:         ||
||              |    |  :AlignCtrl =lp0P0W & \\                              ||
||              |    |  :call Align#AlignCtrl('=lp0P0W','&','\\')            ||
||              |    |                                                       ||
||              |    +-------------------------------------------------------++
||   1st arg    |  = | =  all separator patterns are equivalent and are      ||
||              |    |    simultaneously active. Patterns are |regexp|.      ||
||              |    | C  cycle through separator patterns.  Patterns are    ||
||              |    |    |regexp| and are active sequentially.              ||
||              |    |                                                       ||
||              |  < | <  left justify separator   Separators are justified, ||
||              |    | >  right justify separator  too.  Separator styles    ||
||              |    | |  center separator         are cyclic.               ||
||              |    |                                                       ||
||              |  l | l  left justify   Justification styles are always     ||
||              |    | r  right justify  cyclic (ie. lrc would mean left j., ||
||              |    | c  center         then right j., then center, repeat. ||
||              |    | -  skip this separator                                ||
||              |    | +  re-use last justification method                   ||
||              |    | :  treat rest of text as a field                      ||
||              |    | *  use AlignSkip() function (to skip or not)          ||
||              |    |                                                       ||
||              | p1 | p### pad separator on left  by # blanks               ||
||              | P1 | P### pad separator on right by # blanks               ||
||              |    |                                                       ||
||              |  I | I  preserve and apply first line's leading white      ||
||              |    |    space to all lines                                 ||
||              |    | W  preserve leading white space on every line, even   ||
||              |    |    if it varies from line to line                     ||
||              |    | w  don't preserve leading white space                 ||
||              |    |                                                       ||
||              |    | g  second argument is a selection pattern -- only     ||
||              |    |    align on lines that have a match  (inspired by     ||
||              |    |    :g/selection pattern/command)                      ||
||              |    | v  second argument is a selection pattern -- only     ||
||              |    |    align on lines that _don't_ have a match (inspired ||
||              |    |    by :v/selection pattern/command)                   ||
||              |    |                                                       ||
||              |    | m  Map support: AlignCtrl will immediately do an      ||
||              |    |    AlignPush() and the next call to Align() will do   ||
||              |    |    an AlignPop at the end.  This feature allows maps  ||
||              |    |    to preserve user settings.                         ||
||              |    |                                                       ||
||              |    | default                                               ||
||              |    |    AlignCtrl default                                  ||
||              |    |    will clear the AlignCtrl                           ||
||              |    |    stack & set the default:  AlignCtrl "Ilp1P1=" '='  ||
||              |    |                                                       ||
||              +----+-------------------------------------------------------+|
||  More args   |  More arguments are interpreted as describing separators   ||
||              +------------------------------------------------------------+|
||   No args    |  AlignCtrl will display its current settings               ||
||==============+============================================================+|
||[range]Align  |   [..list-of-separators..]                                 ||
||[range]Align! |   [AlignCtrl settings] [..list-of-separators..]            ||
||              +------------------------------------------------------------+|
||              |  Aligns text over the given range.  The range may be       ||
||              |  selected via visual mode (v, V, or ctrl-v) or via         ||
||              |  the command line.  The Align operation may be invoked     ||
||              |  as a command or as a function; as a function, the first   ||
||              |  argument is 0=separators only, 1=AlignCtrl option string  ||
||              |  followed by a list of separators.                         ||
||              |   :[range]Align                                            ||
||              |   :[range]Align [list of separators]                       ||
||              |   :[range]call Align#Align(0)                              ||
||              |   :[range]call Align#Align(0,"list","of","separators",...) ||
\=============================================================================/

==============================================================================
3. Alignment Usage	*alignusage* *align-usage* *align-userguide* {{{1


ALIGNMENT CONCEPTS			*align-concept* *align-concepts* {{{2

	The typical text to be aligned is considered to be:

		* composed of two or more fields
		* separated by one or more separator pattern(s):
		* two or more lines
>
		ws field ws separator ws field ws separator ...
		ws field ws separator ws field ws separator ...
<
	where "ws" stands for "white space" such as blanks and/or tabs,
	and "fields" are arbitrary text.  For example, consider >

		x= y= z= 3;
		xx= yy= zz= 4;
		zzz= yyy= zzz= 5;
		a= b= c= 3;
<
	Assume that it is desired to line up all the "=" signs; these,
	then, are the separators.  The fields are composed of all the
	alphameric text.  Assuming they lie on lines 1-4, one may align
	those "=" signs with: >
		:AlignCtrl l
		:1,4Align =
<	The result is: >
		x   = y   = z   = 3;
		xx  = yy  = zz  = 4;
		zzz = yyy = zzz = 5;
		a   = b   = c   = 3;

<	Note how each "=" sign is surrounded by a single space; the
	default padding is p1P1 (p1 means one space before the separator,
	and P1 means one space after it).  If you wish to change the
	padding, say, to no padding, use  (see |alignctrl-p|) >

		:AlignCtrl lp0P0

<	Next, note how each field is left justified; that's what the "l"
	in the AlignCtrl parameters (a small letter "ell") does.  If
	right-justification of the fields had been desired, an "r"
	could've been used: >
		:AlignCtrl r
<	yielding >
		  x =   y =   z = 3;
		 xx =  yy =  zz = 4;
		zzz = yyy = zzz = 5;
		  a =   b =   c = 3;
<	There are many more options available for field justification: see
	|alignctrl-c| and |alignctrl--|.

	Separators, although commonly only one character long, are actually
	specified by regular expressions (see |regexp|), and one may left
	justify, right justify, or center them, too (see |alignctrl-<|).

	Assume that for some reason a left-right-left-right-... justification
	sequence was desired.  This wish is simply achieved with >
		:AlignCtrl lr
		:1,4Align =
<	because the justification commands are considered to be "cyclic"; ie.
	lr is the same as lrlrlrlrlrlrlr...

	There's a lot more discussed under |alignctrl|; hopefully the examples
	there will help, too.


ALIGNMENT COMMANDS			*align-command* *align-commands* {{{2

        The <Align.vim> script includes two primary commands and two
	minor commands:

	  AlignCtrl : this command/function sets up alignment options
	              which persist until changed for later Align calls.
		      It controls such things as: how to specify field
		      separators, initial white space, padding about
		      separators, left/right/center justification, etc. >
			ex.  AlignCtrl wp0P1
                             Interpretation: during subsequent alignment
			     operations, preserve each line's initial
			     whitespace.  Use no padding before separators
			     but provide one padding space after separators.
<
	  Align     : this command/function operates on the range given it to
		      align text based on one or more separator patterns.  The
		      patterns may be provided via AlignCtrl or via Align
		      itself. >

			ex. :%Align ,
			    Interpretation: align all commas over the entire
			    file.
<		      The :Align! format permits alignment control commands
		      to precede the alignment patterns. >
			ex. :%Align! p2P2 =
<		      This will align all "=" in the file with two padding
		      spaces on both sides of each "=" sign.

		      NOTE ON USING PATTERNS WITH ALIGN:~
		      Align and AlignCtrl use |<q-args>| to obtain their
		      input patterns and they use an internal function to
		      split arguments at whitespace unless inside "..."s.
		      One may escape characters inside a double-quote string
		      by preceding such characters with a backslash.

	  AlignPush : this command/function pushes the current AlignCtrl
	              state onto an internal stack. >
			ex. :AlignPush
			    Interpretation: save the current AlignCtrl
			    settings, whatever they may be.  They'll
			    also remain as the current settings until
			    AlignCtrl is used to change them.
<
	  AlignPop  : this command/function pops the current AlignCtrl
	              state from an internal stack. >
			ex. :AlignPop
			    Interpretation: presumably AlignPush was
			    used (at least once) previously; this command
			    restores the AlignCtrl settings when AlignPush
			    was last used.
<	              Also see |alignctrl-m| for a way to automatically do
	              an AlignPop after an Align (primarily this is for maps).

ALIGNMENT OPTIONS	*align-option* *align-options* *align-xstrlen* {{{2
    *align-utf8* *align-utf* *align-codepoint* *align-strlen* *align-multibyte*

	For those of you who are using 2-byte (or more) characters such as are
	available with utf-8, Align now provides a special option which you
	may choose based upon your needs:

	Use Built-in strlen() ~
>
			let g:Align_xstrlen= 0

<       This is the fastest method, but it doesn't handle multibyte characters
	well.  It is the default for:

	  enc=latin1
	  vim compiled without multi-byte support
	  $LANG is en_US.UTF-8 (assuming USA english)

	Number of codepoints (Latin a + combining circumflex are two codepoints)~
>
			let g:Align_xstrlen= 1              (default)
<
	Number of spacing codepoints (Latin a + combining circumflex is one~
	spacing codepoint; a hard tab is one; wide and narrow CJK are one~
	each; etc.)~
>